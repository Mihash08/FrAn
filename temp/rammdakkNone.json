[{"text": "#include <iostream>\n\nstruct Edge {\n    int left_index, right_index, weight;\n\npublic:\n    int compare(Edge compare) {\n        return (weight < compare.weight);\n    }\n};\n\nint findN(int val, int* parent) {\n    while (val != parent[val]) {\n        val = parent[val];\n    }\n    return val;\n}\n\nint combine(int first, int second, int* parent) {\n    first = findN(first, parent);\n    second = findN(second, parent);\n    if (first == second) {\n        return 0;\n    }\n    parent[second] = first;\n    return 1;\n}\n\nvoid swap(Edge* a, Edge* b) {\n    Edge t = *a;\n    *a = *b;\n    *b = t;\n}\n\nint partition(Edge arr[], int low, int high) {\n    Edge pivot = arr[high];\n    int i = (low - 1);\n    for (int j = low; j <= high - 1; j++) {\n        if (arr[j].weight <= pivot.weight) {\n            i++;\n            swap(&arr[i], &arr[j]);\n        }\n    }\n    swap(&arr[i + 1], &arr[high]);\n    return (i + 1);\n}\n\nvoid quickSort(Edge arr[], int low, int high) {\n    if (low < high) {\n        int pi = partition(arr, low, high);\n        quickSort(arr, low, pi - 1);\n        quickSort(arr, pi + 1, high);\n    }\n}\n\nint main() {\n    int n_val, m_val;\n    std::cin >> n_val >> m_val;\n    int* parent = new int[n_val + 1];\n    for (int i = 1; i <= n_val; ++i) {\n        parent[i] = i;\n    }\n    Edge* e = new Edge[m_val];\n    for (int i = 0; i < m_val; ++i) {\n        std::cin >> e[i].left_index >> e[i].right_index >> e[i].weight;\n    }\n    quickSort(e, 0, m_val);\n    int res = 0;\n    for (int i = 0; i < m_val; ++i) {\n        if (combine(e[i].left_index, e[i].right_index, parent)) {\n            res += e[i].weight;\n        }\n    }\n    std::cout << res << \"\\n\";\n    delete[] parent;\n    delete[] e;\n    _CrtDumpMemoryLeaks();\n    return 0;\n}", "out": true, "date": "2021-12-07T21:31:31+00:00", "id": 71121}, {"text": "for (int index = 0; index < number_of_vertices - 1; ++index) {\n    while (vertices[lines[ind].first] == vertices[lines[ind].second]) {\n        ind++;\n    }\n    counter += lines[ind].weight;\n    int first = vertices[lines[ind].first];\n    int second = vertices[lines[ind].second];\n    for (int j = 1; j <= number_of_vertices; ++j) {\n        if (vertices[j] == second) {\n            vertices[j] = first;\n        }\n    }\n    ind++;\n}", "out": false, "date": "2021-12-07T21:29:32+00:00", "id": 71120}, {"text": "https://t.me/joinchat/RJikQVRfTmYwZTEy/", "out": false, "date": "2021-12-07T21:21:36+00:00", "id": 71119}, {"text": "\u0432 \u043e\u0431\u0449\u0435\u043c) \u0441\u043f\u043e\u0439\u043b\u0435\u0440 \u0435\u0441\u043b\u0438 \u043d\u0430\u043f\u0438\u0441\u0442\u044c \u043c\u0435\u0442\u043e\u0434 \u0442\u0430\u043a: \n bool verify(const std::string &obj) {\n        return true;\n    }\n\n\u0430 \u0432 getFPRate() \u0432\u0441\u0435\u0433\u0434\u0430 \u0432\u043e\u0437\u0440\u0430\u0449\u0430\u0442\u044c 0, \u0442\u043e \u043f\u0440\u043e\u0439\u0434\u0451\u0442 \u0432\u0441\u0435 \u0442\u0435\u0441\u0442\u044b \u043a\u0440\u043e\u043c\u0435 7 \u0438 8", "out": false, "date": "2021-12-07T21:20:15+00:00", "id": 71118}, {"text": "\u043d\u0430 22 \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u043d\u043e, \u0438 \u0435\u0441\u043b\u0438 \u0435\u0449\u0435 \u0433\u0434\u0435-\u0442\u043e \u0437\u0430\u043c\u0435\u0442\u0438\u0442\u0435", "out": true, "date": "2021-12-07T19:28:48+00:00", "id": 71117}, {"text": "\u043d\u0430 12 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u0435 \u043c\u043e\u0436\u0435\u0442\u0435 \u043e\u0442\u043c\u0435\u0442\u0438\u0442\u044c \u0447\u0442\u043e \u0432\u0435\u0431 \u043d\u0435 \u043d\u0443\u0436\u0435\u043d? \u043c\u044b \u0437\u0430\u0442\u0443\u043f\u0438\u043b\u0438", "out": true, "date": "2021-12-07T19:28:48+00:00", "id": 71116}]